var documenterSearchIndex = {"docs":
[{"location":"api/#PiGPIO-API","page":"API Docs","title":"PiGPIO API","text":"","category":"section"},{"location":"api/","page":"API Docs","title":"API Docs","text":"","category":"page"},{"location":"api/","page":"API Docs","title":"API Docs","text":"Modules = [PiGPIO]","category":"page"},{"location":"api/#PiGPIO.Callback","page":"API Docs","title":"PiGPIO.Callback","text":"A class to provide GPIO level change callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.CallbackThread","page":"API Docs","title":"PiGPIO.CallbackThread","text":"A class to encapsulate pigpio notification callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.CallbackThread-Tuple{Any, Any, Any}","page":"API Docs","title":"PiGPIO.CallbackThread","text":"Initialises notifications.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.Callback_ADT","page":"API Docs","title":"PiGPIO.Callback_ADT","text":"An ADT class to hold callback information\n\ngpio: Broadcom GPIO number.\nedge: PiGPIO.EITHER_EDGE, PiGPIO.RISING_EDGE, or PiGPIO.FALLING_EDGE.\nfunc: a user function taking three arguments (GPIO, level, tick).\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.Pi-Tuple{}","page":"API Docs","title":"PiGPIO.Pi","text":"Pi(; host = get(ENV, \"PIGPIO_ADDR\", \"\"),\n   port = get(ENV, \"PIGPIO_PORT\", 8888))\n\nGrants access to a Pi's GPIO.\n\nhost is the host name of the Pi on which the pigpio daemon is  running.  The default is localhost unless overridden by  the PIGPIO_ADDR environment variable.\n\nport is the port number on which the pigpio daemon is listening.  The default is 8888 unless overridden by the PIGPIO_PORT  environment variable.  The pigpio daemon must have been  started with the same port number.\n\nThis connects to the pigpio daemon and reserves resources to be used for sending commands and receiving notifications.\n\nAn instance attribute connected may be used to check the success of the connection.  If the connection is established successfully connected will be true, otherwise false.\n\npi = PiGPIO.Pi()                           # use defaults\npi = PiGPIO.Pi(host = \"mypi\")              # specify host, default port\npi = PiGPIO.Pi(host = \"mypi\", port = 7777) # specify host and port\n\npi = PiGPIO.Pi()                           # exit script if no connection\nif !pi.connected\n   exit()\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.Pulse","page":"API Docs","title":"PiGPIO.Pulse","text":"A class to store pulse information.\n\ngpio_on: the GPIO to switch on at the start of the pulse. gpio_off: the GPIO to switch off at the start of the pulse. delay: the delay in microseconds before the next pulse.\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.SockLock","page":"API Docs","title":"PiGPIO.SockLock","text":"A class to store socket and lock.\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.WaitForEdge","page":"API Docs","title":"PiGPIO.WaitForEdge","text":"Encapsulates waiting for GPIO edges.\n\n\n\n\n\n","category":"type"},{"location":"api/#PiGPIO.WaitForEdge-Tuple{Any, Int64, Any, Any}","page":"API Docs","title":"PiGPIO.WaitForEdge","text":"Initialises a waitforedge.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.run-Tuple{PiGPIO.CallbackThread}","page":"API Docs","title":"Base.run","text":"Runs the notification thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO._pigpio_command","page":"API Docs","title":"PiGPIO._pigpio_command","text":"Runs a pigpio socket command.\n\nsl: command socket and lock.\ncmd: the command to be executed.\np1: command parameter 1 (if applicable).\np2: command parameter 2 (if applicable).\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO._pigpio_command_ext","page":"API Docs","title":"PiGPIO._pigpio_command_ext","text":"Runs an extended pigpio socket command.\n\nsl: command socket and lock.\ncmd: the command to be executed.\np1: command parameter 1 (if applicable).\np2: command parameter 2 (if applicable).\np3: total size in bytes of following extents\nextents: additional data blocks\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO._tally-Tuple{PiGPIO.Callback, Any, Any, Any}","page":"API Docs","title":"PiGPIO._tally","text":"Increment the callback called count.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO._u2i-Tuple{UInt32}","page":"API Docs","title":"PiGPIO._u2i","text":"Converts a 32 bit unsigned number to signed.  If the number is negative it indicates an error.  On error a pigpio exception will be raised if exceptions is true.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.append-Tuple{PiGPIO.CallbackThread, Any}","page":"API Docs","title":"PiGPIO.append","text":"Adds a callback to the notification thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_i2c_close-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.bb_i2c_close","text":"This function stops bit banging I2C on a pair of GPIO previously opened with bb_i2c_open.\n\nSDA: 0-31, the SDA GPIO used in a prior call to bb_i2c_open\n\nReturns 0 if OK, otherwise PiGPIO.PI_BAD_USER_GPIO, or PiGPIO.PI_NOT_I2C_GPIO.\n\nbb_i2c_close(pi, SDA)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_i2c_open","page":"API Docs","title":"PiGPIO.bb_i2c_open","text":"This function selects a pair of GPIO for bit banging I2C at a specified baud rate.\n\nBit banging I2C allows for certain operations which are not possible with the standard I2C driver.\n\no baud rates as low as 50 o repeated starts o clock stretching o I2C on any pair of spare GPIO\n\nSDA: 0-31\nSCL: 0-31\nbaud: 50-500000\n\nReturns 0 if OK, otherwise PiGPIO.PI_BAD_USER_GPIO, PiGPIO.PI_BAD_I2C_BAUD, or PiGPIO.PI_GPIO_IN_USE.\n\nnote: Note\nThe GPIO used for SDA and SCL must have pull-ups to 3V3 connected. As a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.\n\nh = bb_i2c_open(pi, 4, 5, 50000) # bit bang on GPIO 4/5 at 50kbps\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.bb_i2c_zip-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.bb_i2c_zip","text":"This function executes a sequence of bit banged I2C operations. The operations to be performed are specified by the contents of data which contains the concatenated command codes and associated data.\n\nSDA: 0-31 (as used in a prior call to bb_i2c_open)\ndata: the concatenated I2C commands, see below\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(count, data) = pi.bb_i2c_zip(\n             h, [4, 0x53, 2, 7, 1, 0x32, 2, 6, 6, 3, 0])\n\nThe following command codes are supported\n\nName    @ Cmd & Data   @ Meaning\nEnd     @ 0            @ No more commands\nEscape  @ 1            @ Next P is two bytes\nStart   @ 2            @ Start condition\nStop    @ 3            @ Stop condition\nAddress @ 4 P          @ Set I2C address to P\nFlags   @ 5 lsb msb    @ Set I2C flags to lsb + (msb << 8)\nRead    @ 6 P          @ Read P bytes of data\nWrite   @ 7 P ...      @ Write P bytes of data\n\nThe address, read, and write commands take a parameter P. Normally P is one byte (0-255).  If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).\n\nThe address and flags default to 0.  The address and flags maintain their previous value until updated.\n\nNo flags are currently defined.\n\nAny read I2C data is concatenated in the returned bytearray.\n\nSet address 0x53\nstart, write 0x32, (re)start, read 6 bytes, stop\nSet address 0x1E\nstart, write 0x03, (re)start, read 6 bytes, stop\nSet address 0x68\nstart, write 0x1B, (re)start, read 8 bytes, stop\nEnd\n\n0x04 0x53\n0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03\n\n0x04 0x1E\n0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03\n\n0x04 0x68\n0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03\n\n0x00\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_serial_invert-Tuple{Any, Any, Any}","page":"API Docs","title":"PiGPIO.bb_serial_invert","text":"Invert serial logic.\n\nuser_gpio: 0-31 (opened in a prior call to bb_serial_read_open)\ninvert: 0-1 (1 invert, 0 normal)\n\nstatus = bb_serial_invert(pi, 17, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_serial_read-Tuple{Any, Any}","page":"API Docs","title":"PiGPIO.bb_serial_read","text":"Returns data from the bit bang serial cyclic buffer.\n\nuser_gpio: 0-31 (opened in a prior call to bb_serial_read_open)\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\nThe bytes returned for each character depend upon the number of data bits bb_bits specified in the bb_serial_read_open command.\n\nFor bb_bits 1-8 there will be one byte per character. For bb_bits 9-16 there will be two bytes per character. For bb_bits 17-32 there will be four bytes per character.\n\n(count, data) = bb_serial_read(pi, 4)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_serial_read_close-Tuple{Any, Any}","page":"API Docs","title":"PiGPIO.bb_serial_read_close","text":"Closes a GPIO for bit bang reading of serial data.\n\nuser_gpio: 0-31 (opened in a prior call to bb_serial_read_open)\n\nstatus = bb_serial_read_close(pi, 17)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.bb_serial_read_open","page":"API Docs","title":"PiGPIO.bb_serial_read_open","text":"Opens a GPIO for bit bang reading of serial data.\n\nuser_gpio: 0-31, the GPIO to use.\nbaud: 50-250000, the baud rate.\nbb_bits: 1-32, the number of bits per word, default 8.\n\nThe serial data is held in a cyclic buffer and is read using bb_serial_read.\n\nIt is the caller's responsibility to read data from the cyclic buffer in a timely fashion.\n\nstatus = bb_serial_read_open(pi, 4, 19200)\nstatus = bb_serial_read_open(pi, 17, 9600)\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.callback","page":"API Docs","title":"PiGPIO.callback","text":"PiGPIO.callback(self::Pi, user_gpio, edge=RISING_EDGE, func=nothing)\n\nCalls a user supplied function (a callback) whenever the specified GPIO edge is detected.\n\nuser_gpio: 0-31.\nedge: PiGPIO.EITHER_EDGE, PiGPIO.RISING_EDGE (default), or PiGPIO.FALLING_EDGE.\nfunc: user supplied callback function.\n\nThe user supplied callback receives three parameters, the GPIO, the level, and the tick.\n\nIf a user callback is not specified a default tally callback is provided which simply counts edges.  The count may be retrieved by calling the tally function.  The count may be reset to zero by calling the reset_tally function.\n\nThe callback may be cancelled by calling the cancel function.\n\nA GPIO may have multiple callbacks (although I can't think of a reason to do so).\n\nfunction cbf(gpio, level, tick)\n   print(gpio, level, tick)\nend\n\ncb1 = callback(pi, 22, PiGPIO.EITHER_EDGE, cbf)\n\ncb2 = callback(pi, 4, PiGPIO.EITHER_EDGE)\n\ncb3 = callback(pi, 17)\n\nprint(cb3.tally())\n\ncb3.reset_tally()\n\ncb1.cancel() # To cancel callback cb1.\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.cancel-Tuple{Any}","page":"API Docs","title":"PiGPIO.cancel","text":"Cancels a callback by removing it from the notification thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.clear_bank_1-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.clear_bank_1","text":"PiGPIO.clear_bank_1(self::Pi, bits)\n\nClears GPIO 0-31 if the corresponding bit in bits is set.\n\nbits is a 32 bit mask with 1 set if the corresponding GPIO is  to be cleared.\n\nA returned status of PiGPIO.PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.\n\nclear_bank_1(pi,0b111110010000)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.clear_bank_2-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.clear_bank_2","text":"PiGPIO.clear_bank_2(self::Pi, bits)\n\nClears GPIO 32-53 if the corresponding bit (0-21) in bits is set.\n\nbits is a 32 bit mask with 1 set if the corresponding GPIO is to be cleared.\n\nA returned status of PiGPIO.PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.\n\nclear_bank_2(pi, 0x1010)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.custom_1","page":"API Docs","title":"PiGPIO.custom_1","text":"PiGPIO.custom_1(self, arg1=0, arg2=0, argx=[])\n\nCalls a pigpio function customised by the user.\n\narg1 is >=0, default 0. arg2 is >=0, default 0. argx is an extra arguments (each 0-255), default empty.\n\nThe returned value is an integer which by convention should be >=0 for OK and <0 for error.\n\nvalue = PiGPIO.custom_1(pi)\n\nvalue = PiGPIO.custom_1(pi, 23)\n\nvalue = PiGPIO.custom_1(pi, 0, 55)\n\nvalue = PiGPIO.custom_1(pi, 23, 56, [1, 5, 7])\n\nvalue = PiGPIO.custom_1(pi, 23, 56, b\"hello\")\n\nvalue = PiGPIO.custom_1(pi, 23, 56, \"hello\")\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.custom_2","page":"API Docs","title":"PiGPIO.custom_2","text":"PiGPIO.custom_2(self, arg1=0, argx=[], retMax=8192)\n\nCalls a pigpio function customised by the user.\n\narg1 is >=0, default 0. argx  extra arguments (each 0-255), default empty. retMax is >=0, maximum number of bytes to return, default 8192.\n\nThe returned value is a tuple of the number of bytes returned and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(count, data) = PiGPIO.custom_2(pi)\n\n(count, data) = PiGPIO.custom_2(pi, 23)\n\n(count, data) = PiGPIO.custom_2(pi, 23, [1, 5, 7])\n\n(count, data) = PiGPIO.custom_2(pi, 23, b\"hello\")\n\n(count, data) = PiGPIO.custom_2(pi, 23, \"hello\", 128)\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.error_text-Tuple{Any}","page":"API Docs","title":"PiGPIO.error_text","text":"PiGPIO.error_text(errnum)\n\nReturns a text description of a PiGPIO error number. errnum (errnum <0).\n\nprint(PiGPIO.error_text(-5))\n# output: level not 0-1\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.func-Tuple{PiGPIO.WaitForEdge, Any, Any, Any}","page":"API Docs","title":"PiGPIO.func","text":"Sets waitforedge triggered.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_PWM_dutycycle-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_PWM_dutycycle","text":"PiGPIO.get_PWM_dutycycle(self::Pi, user_gpio)\n\nReturns the PWM dutycycle being used on the GPIO.\n\nuser_gpio: 0-31.\n\nFor normal PWM the dutycycle will be out of the defined range for the GPIO (see get_PWM_range).\n\nIf a hardware clock is active on the GPIO the reported dutycycle will be 500000 (500k) out of 1000000 (1M).\n\nIf hardware PWM is active on the GPIO the reported dutycycle will be out of a 1000000 (1M).\n\nset_PWM_dutycycle(pi, 4, 25)\nprint(get_PWM_dutycycle(pi, 4))\n# output 25\n\nset_PWM_dutycycle(pi, 4, 203)\nprint(get_PWM_dutycycle(pi, 4))\n# output 203\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_PWM_frequency-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_PWM_frequency","text":"Returns the frequency of PWM being used on the GPIO.\n\nuser_gpio= 0-31.\n\nReturns the frequency (in Hz) used for the GPIO.\n\nFor normal PWM the frequency will be that defined for the GPIO by set_PWM_frequency.\n\nIf a hardware clock is active on the GPIO the reported frequency will be that set by hardware_clock.\n\nIf hardware PWM is active on the GPIO the reported frequency will be that set by hardware_PWM.\n\nset_PWM_frequency(pi, 4,0)\nprint(get_PWM_frequency(pi, 4))\n10\n\nset_PWM_frequency(pi, 4, 800)\nprint(get_PWM_frequency(pi, 4))\n800\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_PWM_range-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_PWM_range","text":"PiGPIO.get_PWM_range(self::Pi, user_gpio)\n\nReturns the range of PWM values being used on the GPIO. user_gpio is an integer between 0 and 31.\n\nIf a hardware clock or hardware PWM is active on the GPIO the reported range will be 1000000 (1M).\n\nset_PWM_range(pi, 9, 500)\nprint(get_PWM_range(pi, 9))\n# output 500\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_PWM_real_range-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_PWM_real_range","text":"PiGPIO.get_PWM_real_range(self::Pi, user_gpio)\n\nReturns the real (underlying) range of PWM values being used on the GPIO.\n\nuser_gpio: 0-31.\n\nIf a hardware clock is active on the GPIO the reported real range will be 1000000 (1M).\n\nIf hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.\n\nset_PWM_frequency(pi, 4, 800)\nprint(get_PWM_real_range(pi, 4))\n# output 250\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_current_tick-Tuple{Pi}","page":"API Docs","title":"PiGPIO.get_current_tick","text":"PiGPIO.get_current_tick(self::Pi)\n\nReturns the current system tick.\n\nTick is the number of microseconds since system boot.  As an unsigned 32 bit quantity tick wraps around approximately every 71.6 minutes.\n\nt1 = PiGPIO.get_current_tick(pi)\nsleep(1)\nt2 = PiGPIO.get_current_tick(pi)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_hardware_revision-Tuple{Pi}","page":"API Docs","title":"PiGPIO.get_hardware_revision","text":"PiGPIO.get_hardware_revision(self::Pi)\n\nReturns the Pi's hardware revision number.\n\nThe hardware revision is the last few characters on the revision line of /proc/cpuinfo.\n\nThe revision number can be used to determine the assignment of GPIO to pins (see gpio).\n\nThere are at least three types of board.\n\nType 1 boards have hardware revision numbers of 2 and 3.\n\nType 2 boards have hardware revision numbers of 4, 5, 6, and 15.\n\nType 3 boards have hardware revision numbers of 16 or greater.\n\nIf the hardware revision can not be found or is not a valid hexadecimal number the function returns 0.\n\nprint(get_hardware_revision(pi))\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_mode-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_mode","text":"get_mode(self::Pi, gpio)\n\nReturns the GPIO mode for the pin gpio (integer between 0 and 53).\n\nReturns a value as follows:\n\n0 = INPUT\n1 = OUTPUT\n2 = ALT5\n3 = ALT4\n4 = ALT0\n5 = ALT1\n6 = ALT2\n7 = ALT3\n\nprint(get_mode(pi, 0))\n# output 4\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_pigpio_version-Tuple{Pi}","page":"API Docs","title":"PiGPIO.get_pigpio_version","text":"PiGPIO.get_pigpio_version(self::Pi)\n\nReturns the pigpio software version.\n\nv = get_pigpio_version(pi)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.get_servo_pulsewidth-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.get_servo_pulsewidth","text":"Returns the servo pulsewidth being used on the GPIO.\n\nuser_gpio: 0-31.\n\nReturns the servo pulsewidth.\n\nset_servo_pulsewidth(pi, 4, 525)\nprint(get_servo_pulsewidth(pi, 4))\n525\n\nset_servo_pulsewidth(pi, 4, 2130)\nprint(get_servo_pulsewidth(pi, 4))\n2130\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.hardware_PWM-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.hardware_PWM","text":"PiGPIO.hardware_PWM(self::Pi, gpio, PWMfreq, PWMduty)\n\nStarts hardware PWM on a GPIO at the specified frequency and dutycycle. Frequencies above 30MHz are unlikely to work.\n\nnote: Note\nAny waveform started by wave_send_once, wave_send_repeat, or wave_chain will be cancelled.\n\nThis function is only valid if the pigpio main clock is PCM. The main clock defaults to PCM but may be overridden when the pigpio daemon is started (option -t).\n\ngpio: see descripton, PWMfreq: 0 (off) or 1-125000000 (125M), PWMduty: 0 (off) to 1000000 (1M)(fully on).\n\nReturns 0 if OK, otherwise PiGPIO.PI_NOT_PERMITTED, PiGPIO.PI_BAD_GPIO, PiGPIO.PI_NOT_HPWM_GPIO, PiGPIO.PI_BAD_HPWM_DUTY, PiGPIO.PI_BAD_HPWM_FREQ.\n\nThe same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel.\n\nThe GPIO must be one of the following.\n\n12  PWM channel 0  All models but A and B\n13  PWM channel 1  All models but A and B\n18  PWM channel 0  All models\n19  PWM channel 1  All models but A and B\n\n40  PWM channel 0  Compute module only\n41  PWM channel 1  Compute module only\n45  PWM channel 1  Compute module only\n52  PWM channel 0  Compute module only\n53  PWM channel 1  Compute module only\n\nThe actual number of steps beween off and fully on is the integral part of 250 million divided by PWMfreq.\n\nThe actual frequency set is 250 million / steps.\n\nThere will only be a million steps for a PWMfreq of 250. Lower frequencies will have more steps and higher frequencies will have fewer steps.  PWMduty is automatically scaled to take this into account.\n\nPiGPIO.hardware_PWM(pi, 18, 800, 250000) # 800Hz 25% dutycycle\n\nPiGPIO.hardware_PWM(pi, 18, 2000, 750000) # 2000Hz 75% dutycycle\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.hardware_clock-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.hardware_clock","text":"PiGPIO.hardware_clock(self::Pi, gpio, clkfreq)\n\nStarts a hardware clock on a GPIO at the specified frequency. Frequencies above 30MHz are unlikely to work. See description below for the gpio parameter. clkfreq is 0 (off) or 4689-250000000 (250M)\n\nReturns 0 if OK, otherwise PiGPIO.PI_NOT_PERMITTED, PiGPIO.PI_BAD_GPIO, PiGPIO.PI_NOT_HCLK_GPIO, PiGPIO.PI_BAD_HCLK_FREQ, or PiGPIO.PI_BAD_HCLK_PASS.\n\nThe same clock is available on multiple GPIO.  The latest frequency setting will be used by all GPIO which share a clock.\n\nThe GPIO must be one of the following.\n\n4   clock 0  All models\n5   clock 1  All models but A and B (reserved for system use)\n6   clock 2  All models but A and B\n20  clock 0  All models but A and B\n21  clock 1  All models but A and Rev.2 B (reserved for system use)\n\n32  clock 0  Compute module only\n34  clock 0  Compute module only\n42  clock 1  Compute module only (reserved for system use)\n43  clock 2  Compute module only\n44  clock 1  Compute module only (reserved for system use)\n\nAccess to clock 1 is protected by a password as its use will likely crash the Pi.  The password is given by or'ing 0x5A000000 with the GPIO number.\n\nhardware_clock(pi, 4, 5000) # 5 KHz clock on GPIO 4\n\nhardware_clock(pi, 4, 40000000) # 40 MHz clock on GPIO 4\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_block_process_call-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_block_process_call","text":"Writes data bytes to the specified register of the device associated with handle and reads a device specified number of bytes of data in return.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\ndata: the bytes to write.\n\nThe SMBus 2.0 documentation states that a minimum of 1 byte may be sent and a minimum of 1 byte may be received.  The total number of bytes sent/received must be 32 or less.\n\nSMBus 2.0 5.5.8 - Block write-block read.\n\nS Addr Wr [A] reg [A] length(data) [A] data0 [A] ... datan [A]\nS Addr Rd [A] [Count] A [Data] ... A P\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(b, d) = i2c_block_process_call(pi, h, 10, b'\\x02\\x05\\x00')\n\n(b, d) = i2c_block_process_call(pi, h, 10, b'abcdr')\n\n(b, d) = i2c_block_process_call(pi, h, 10, \"abracad\")\n\n(b, d) = i2c_block_process_call(pi, h, 10, [2, 5, 16])\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_close-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.i2c_close","text":"Closes the I2C device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\n\ni2c_close(pi, h)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_open","page":"API Docs","title":"PiGPIO.i2c_open","text":"Returns a handle (>=0) for the device at the I2C bus address.\n\ni2c_bus: >=0.\ni2c_address: 0-0x7F.\ni2c_flags: 0, no flags are currently defined.\n\nNormally you would only use the i2c_* functions if you are or will be connecting to the Pi over a network.  If you will always run on the local Pi use the standard SMBus module instead.\n\nPhysically buses 0 and 1 are available on the Pi.  Higher numbered buses will be available if a kernel supported bus multiplexor is being used.\n\nFor the SMBus commands the low level transactions are shown at the end of the function description.  The following abbreviations are used.\n\nS     (1 bit) : Start bit\nP     (1 bit) : Stop bit\nRd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.\nA, NA (1 bit) : Accept and not accept bit.\nAddr  (7 bits): I2C 7 bit address.\nreg   (8 bits): Command byte, which often selects a register.\nData  (8 bits): A data byte.\nCount (8 bits): A byte defining the length of a block operation.\n\n[..]: Data sent by the device.\n\nh = i2c_open(pi, 1, 0x53) # open device at address 0x53 on bus 1\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.i2c_process_call-NTuple{4, Any}","page":"API Docs","title":"PiGPIO.i2c_process_call","text":"Writes 16 bits of data to the specified register of the device associated with handle and reads 16 bits of data in return.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\nword_val: 0-65535, the value to write.\n\nSMBus 2.0 5.5.6 - Process call.\n\nS Addr Wr [A] reg [A] word_val_Low [A] word_val_High [A]\nS Addr Rd [A] [DataLow] A [DataHigh] NA P\n\nr = i2c_process_call(pi, h, 4, 0x1231)\nr = i2c_process_call(pi, h, 6, 0)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_block_data-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_read_block_data","text":"Reads a block of up to 32 bytes from the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\n\nSMBus 2.0 5.5.7 - Block read.\n\nS Addr Wr [A] reg [A]\nS Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA P\n\nThe amount of returned data is set by the device.\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(b, d) = i2c_read_block_data(pi, h, 10)\nif b >= 0\n# process data\nelse\n# process read failure\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_byte-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.i2c_read_byte","text":"Reads a single byte from the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\n\nSMBus 2.0 5.5.3 - Receive byte.\n\nS Addr Rd [A] [Data] NA P\n\nb = i2c_read_byte(pi, 2) # read a byte from device 2\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_byte_data-Tuple{Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_read_byte_data","text":"Reads a single byte from the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\n\nSMBus 2.0 5.5.5 - Read byte.\n\nS Addr Wr [A] reg [A] S Addr Rd [A] [Data] NA P\n\n# read byte from reg 17 of device 2\nb = i2c_read_byte_data(pi, 2, 17)\n\n# read byte from reg  1 of device 0\nb = i2c_read_byte_data(pi, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_device-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_read_device","text":"Returns count bytes read from the raw device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\ncount: >0, the number of bytes to read.\n\nS Addr Rd [A] [Data] A [Data] A ... A [Data] NA P\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(count, data) = i2c_read_device(pi, h, 12)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_i2c_block_data-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_read_i2c_block_data","text":"Reads count bytes from the specified register of the device associated with handle .  The count may be 1-32.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\ncount: >0, the number of bytes to read.\n\nS Addr Wr [A] reg [A]\nS Addr Rd [A] [Data] A [Data] A ... A [Data] NA P\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(b, d) = i2c_read_i2c_block_data(pi, h, 4, 32)\nif b >= 0\n# process data\nelse\n# process read failure\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_read_word_data-Tuple{Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_read_word_data","text":"Reads a single 16 bit word from the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\n\nSMBus 2.0 5.5.5 - Read word.\n\nS Addr Wr [A] reg [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P\n\n# read word from reg 2 of device 3\nw = i2c_read_word_data(pi, 3, 2)\n\n# read word from reg 7 of device 2\nw = i2c_read_word_data(pi, 2, 7)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_block_data-NTuple{4, Any}","page":"API Docs","title":"PiGPIO.i2c_write_block_data","text":"Writes up to 32 bytes to the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\ndata: the bytes to write.\n\nSMBus 2.0 5.5.7 - Block write.\n\nS Addr Wr [A] reg [A] length(data) [A] data0 [A] data1 [A] ... [A]\ndatan [A] P\n\ni2c_write_block_data(pi, 4, 5, b'hello')\n\ni2c_write_block_data(pi, 4, 5, \"data bytes\")\n\ni2c_write_block_data(pi, 5, 0, b'\\x00\\x01\\x22')\n\ni2c_write_block_data(pi, 6, 2, [0, 1, 0x22])\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_byte-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_byte","text":"Sends a single byte to the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nbyte_val: 0-255, the value to write.\n\nSMBus 2.0 5.5.2 - Send byte.\n\nS Addr Wr [A] byte_val [A] P\n\ni2c_write_byte(pi, 1, 17)   # send byte   17 to device 1\ni2c_write_byte(pi, 2, 0x23) # send byte 0x23 to device 2\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_byte_data-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_byte_data","text":"Writes a single byte to the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\nbyte_val: 0-255, the value to write.\n\nSMBus 2.0 5.5.4 - Write byte.\n\nS Addr Wr [A] reg [A] byte_val [A] P\n\n# send byte 0xC5 to reg 2 of device 1\ni2c_write_byte_data(pi, 1, 2, 0xC5)\n\n# send byte 9 to reg 4 of device 2\ni2c_write_byte_data(pi, 2, 4, 9)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_device-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_device","text":"Writes the data bytes to the raw device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\ndata: the bytes to write.\n\nS Addr Wr [A] data0 [A] data1 [A] ... [A] datan [A] P\n\ni2c_write_device(pi, h, b\"\\x12\\x34\\xA8\")\n\ni2c_write_device(pi, h, b\"help\")\n\ni2c_write_device(pi, h, 'help')\n\ni2c_write_device(pi, h, [23, 56, 231])\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_i2c_block_data-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_i2c_block_data","text":"Writes data bytes to the specified register of the device associated with handle .  1-32 bytes may be written.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\ndata: the bytes to write.\n\nS Addr Wr [A] reg [A] data0 [A] data1 [A] ... [A] datan [NA] P\n\ni2c_write_i2c_block_data(pi, 4, 5, 'hello')\n\ni2c_write_i2c_block_data(pi, 4, 5, b'hello')\n\ni2c_write_i2c_block_data(pi, 5, 0, b'\\x00\\x01\\x22')\n\ni2c_write_i2c_block_data(pi, 6, 2, [0, 1, 0x22])\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_quick-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_quick","text":"Sends a single bit to the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nbit: 0 or 1, the value to write.\n\nSMBus 2.0 5.5.1 - Quick command.\n\nS Addr bit [A] P\n\ni2c_write_quick(pi, 0, 1) # send 1 to device 0\ni2c_write_quick(pi, 3, 0) # send 0 to device 3\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_write_word_data-Tuple{Pi, Any, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_write_word_data","text":"Writes a single 16 bit word to the specified register of the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\nreg: >=0, the device register.\nword_val: 0-65535, the value to write.\n\nSMBus 2.0 5.5.4 - Write word.\n\nS Addr Wr [A] reg [A] word_val_Low [A] word_val_High [A] P\n\n# send word 0xA0C5 to reg 5 of device 4\ni2c_write_word_data(pi, 4, 5, 0xA0C5)\n\n# send word 2 to reg 2 of device 5\ni2c_write_word_data(pi, 5, 2, 23)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.i2c_zip-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.i2c_zip","text":"This function executes a sequence of I2C operations.  The operations to be performed are specified by the contents of data which contains the concatenated command codes and associated data.\n\nhandle: >=0 (as returned by a prior call to i2c_open).\ndata: the concatenated I2C commands, see below\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(count, data) = i2c_zip(pi, h, [4, 0x53, 7, 1, 0x32, 6, 6, 0])\n\nThe following command codes are supported\n\nName    @ Cmd & Data @ Meaning End     @ 0          @ No more commands Escape  @ 1          @ Next P is two bytes On      @ 2          @ Switch combined flag on Off     @ 3          @ Switch combined flag off Address @ 4 P        @ Set I2C address to P Flags   @ 5 lsb msb  @ Set I2C flags to lsb + (msb << 8) Read    @ 6 P        @ Read P bytes of data Write   @ 7 P ...    @ Write P bytes of data\n\nThe address, read, and write commands take a parameter P. Normally P is one byte (0-255).  If the command is preceded by the Escape command then P is two bytes (0-65535, least significant byte first).\n\nThe address defaults to that associated with the handle. The flags default to 0.  The address and flags maintain their previous value until updated.\n\nAny read I2C data is concatenated in the returned bytearray.\n\nSet address 0x53, write 0x32, read 6 bytes\nSet address 0x1E, write 0x03, read 6 bytes\nSet address 0x68, write 0x1B, read 8 bytes\nEnd\n\n0x04 0x53   0x07 0x01 0x32   0x06 0x06\n0x04 0x1E   0x07 0x01 0x03   0x06 0x06\n0x04 0x68   0x07 0x01 0x1B   0x06 0x08\n0x00\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.notify_begin-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.notify_begin","text":"Starts notifications on a handle.\n\nhandle: >=0 (as returned by a prior call to notify_open)\nbits: a 32 bit mask indicating the GPIO to be notified.\n\nThe notification sends state changes for each GPIO whose corresponding bit in bits is set.\n\nThe following code starts notifications for GPIO 1, 4, 6, 7, and 10 (1234 = 0x04D2 = 0b0000010011010010).\n\nh = notify_open(pi)\nif h >= 0\n    notify_begin(pi, h, 1234)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.notify_close-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.notify_close","text":"Stops notifications on a handle and releases the handle for reuse.\n\nhandle: >=0 (as returned by a prior call to notify_open)\n\nh = notify_open(pi)\nif h >= 0\n    notify_begin(pi, h, 1234)\n    # ...\n    notify_close(pi, h)\n    # ...\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.notify_open-Tuple{Pi}","page":"API Docs","title":"PiGPIO.notify_open","text":"PiGPIO.notify_open(self::Pi)\n\nReturns a notification handle (>=0).\n\nA notification is a method for being notified of GPIO state changes via a pipe.\n\nPipes are only accessible from the local machine so this function serves no purpose if you are using Python from a remote machine.  The in-built (socket) notifications provided by callback should be used instead.\n\nNotifications for handle x will be available at the pipe named /dev/pigpiox (where x is the handle number).\n\nE.g. if the function returns 15 then the notifications must be read from /dev/pigpio15.\n\nNotifications have the following structure.\n\nI seqno\nI flags\nI tick\nI level\n\nseqno: starts at 0 each time the handle is opened and then increments by one for each report.\n\nflags: two flags are defined, PI_NTFY_FLAGS_WDOG and PI_NTFY_FLAGS_ALIVE.  If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the flags indicate a GPIO which has had a watchdog timeout; if bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep alive signal on the pipe/socket and is sent once a minute in the absence of other notification activity.\n\ntick: the number of microseconds since system boot.  It wraps around after 1h12m.\n\nlevel: indicates the level of each GPIO.  If bit 1<<x is set then GPIO x is high.\n\nh = notify_open(pi)\nif h >= 0\n    notify_begin(pi, h, 1234)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.notify_pause-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.notify_pause","text":"Pauses notifications on a handle.\n\nhandle: >=0 (as returned by a prior call to notify_open)\n\nNotifications for the handle are suspended until notify_begin is called again.\n\nh = notify_open(pi)\nif h >= 0\n    notify_begin(pi, h, 1234)\n    # ...\n    notify_pause(pi, h)\n    # ...\n    notify_begin(pi, h, 1234)\n    # ...\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.read-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.read","text":"read(self::Pi, gpio)\n\nReturns the GPIO level for the pin gpio (an integer between 0 and 53).\n\nset_mode(pi, 23, PiGPIO.INPUT)\n\nset_pull_up_down(pi, 23, PiGPIO.PUD_DOWN)\nprint(read(pi, 23))\n# output 0\n\nset_pull_up_down(pi, 23, PiGPIO.PUD_UP)\nprint(read(pi, 23))\n# output 1\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.read_bank_1-Tuple{Pi}","page":"API Docs","title":"PiGPIO.read_bank_1","text":"Returns the levels of the bank 1 GPIO (GPIO 0-31).\n\nThe returned 32 bit integer has a bit set if the corresponding GPIO is high.  GPIO n has bit value (1<<n).\n\nprint(bin(read_bank_1(pi)))\n0b10010100000011100100001001111\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.read_bank_2-Tuple{Pi}","page":"API Docs","title":"PiGPIO.read_bank_2","text":"Returns the levels of the bank 2 GPIO (GPIO 32-53).\n\nThe returned 32 bit integer has a bit set if the corresponding GPIO is high.  GPIO n has bit value (1<<(n-32)).\n\nprint(bin(read_bank_2(pi)))\n0b1111110000000000000000\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.remove-Tuple{PiGPIO.CallbackThread, Any}","page":"API Docs","title":"PiGPIO.remove","text":"Removes a callback from the notification thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.reset_tally-Tuple{PiGPIO.Callback}","page":"API Docs","title":"PiGPIO.reset_tally","text":"Resets the tally count to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.rxbuf-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.rxbuf","text":"Returns count bytes from the command socket.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_close-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.serial_close","text":"Closes the serial device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\n\nserial_close(pi, h1)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_data_available-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.serial_data_available","text":"Returns the number of bytes available to be read from the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\n\nrdy = serial_data_available(pi, h1)\n\nif rdy > 0\n(b, d) = serial_read(pi, h1, rdy)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_open","page":"API Docs","title":"PiGPIO.serial_open","text":"Returns a handle for the serial tty device opened at baud bits per second.\n\ntty: the serial device to open.\nbaud: baud rate in bits per second, see below.\nser_flags: 0, no flags are currently defined.\n\nNormally you would only use the serial_* functions if you are or will be connecting to the Pi over a network.  If you will always run on the local Pi use the standard serial module instead.\n\nThe baud rate must be one of 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, or 230400.\n\nh1 = serial_open(pi, \"/dev/ttyAMA0\", 300)\n\nh2 = serial_open(pi, \"/dev/ttyUSB1\", 19200, 0)\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.serial_read-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.serial_read","text":"Reads up to count bytes from the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\ncount: >0, the number of bytes to read.\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(b, d) = serial_read(pi, h2, 100)\nif b > 0\n# process read data\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_read_byte-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.serial_read_byte","text":"Returns a single byte from the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\n\nb = serial_read_byte(pi, h1)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_write-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.serial_write","text":"Writes the data bytes to the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\ndata: the bytes to write.\n\nserial_write(pi, h1, b'\\x02\\x03\\x04')\n\nserial_write(pi, h2, b'help')\n\nserial_write(pi, h2, \"hello\")\n\nserial_write(pi, h1, [2, 3, 4])\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.serial_write_byte-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.serial_write_byte","text":"Writes a single byte to the device associated with handle.\n\nhandle: >=0 (as returned by a prior call to serial_open).\nbyte_val: 0-255, the value to write.\n\nserial_write_byte(pi, h1, 23)\n\nserial_write_byte(h1, ord(pi, 'Z'))\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_PWM_dutycycle-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_PWM_dutycycle","text":"PiGPIO.set_PWM_dutycycle(self::Pi, user_gpio, dutycycle)\n\nStarts (non-zero dutycycle) or stops (0) PWM pulses on the GPIO.\n\nuser_gpio: 0-31.\ndutycycle: 0-range (range defaults to 255).\n\nThe set_PWM_range function can change the default range of 255.\n\nset_PWM_dutycycle(pi, 4,   0) # PWM off\nset_PWM_dutycycle(pi, 4,  64) # PWM 1/4 on\nset_PWM_dutycycle(pi, 4, 128) # PWM 1/2 on\nset_PWM_dutycycle(pi, 4, 192) # PWM 3/4 on\nset_PWM_dutycycle(pi, 4, 255) # PWM full on\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_PWM_frequency-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_PWM_frequency","text":"Sets the frequency (in Hz) of the PWM to be used on the GPIO.\n\nuser_gpio: 0-31.\nfrequency: >=0 Hz\n\nReturns the numerically closest frequency if OK, otherwise PIBADUSERGPIO or PINOT_PERMITTED.\n\nIf PWM is currently active on the GPIO it will be switched off and then back on at the new frequency.\n\nEach GPIO can be independently set to one of 18 different PWM frequencies.\n\nThe selectable frequencies depend upon the sample rate which may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).  The sample rate is set when the pigpio daemon is started.\n\nThe frequencies for each sample rate are\n\n                     Hertz\n\n     1: 40000 20000 10000 8000 5000 4000 2500 2000 1600\n         1250  1000   800  500  400  250  200  100   50\n\n     2: 20000 10000  5000 4000 2500 2000 1250 1000  800\n          625   500   400  250  200  125  100   50   25\n\n     4: 10000  5000  2500 2000 1250 1000  625  500  400\n          313   250   200  125  100   63   50   25   13\nsample\nrate\n(us)  5:  8000  4000  2000 1600 1000  800  500  400  320\n          250   200   160  100   80   50   40   20   10\n\n     8:  5000  2500  1250 1000  625  500  313  250  200\n          156   125   100   63   50   31   25   13    6\n\n    10:  4000  2000  1000  800  500  400  250  200  160\n          125   100    80   50   40   25   20   10    5\n\nset_PWM_frequency(pi, 4,0)\nprint(get_PWM_frequency(pi, 4))\n10\n\nset_PWM_frequency(pi, 4,100000)\nprint(get_PWM_frequency(pi, 4))\n8000\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_PWM_range-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_PWM_range","text":"PiGPIO.set_PWM_range(self::Pi, user_gpio, range_)\n\nSets the range of PWM values to be used on the GPIO. user_gpio is an integer between 0 and 31 and range_ is between 25 and 40000.\n\nset_PWM_range(pi, 9, 100)  # now  25 1/4,   50 1/2,   75 3/4 on\nset_PWM_range(pi, 9, 500)  # now 125 1/4,  250 1/2,  375 3/4 on\nset_PWM_range(pi, 9, 3000) # now 750 1/4, 1500 1/2, 2250 3/4 on\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_bank_1-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.set_bank_1","text":"PiGPIO.set_bank_1(self::Pi, bits)\n\nSets GPIO 0-31 if the corresponding bit in bits is set.\n\nbits is a 32 bit mask with 1 set if the corresponding GPIO is  to be set.\n\nA returned status of PiGPIO.PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.\n\nset_bank_1(pi, 0b111110010000)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_bank_2-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.set_bank_2","text":"Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.\n\nbits: a 32 bit mask with 1 set if the corresponding GPIO is\n\nto be set.\n\nA returned status of PiGPIO.PI_SOME_PERMITTED indicates that the user is not allowed to write to one or more of the GPIO.\n\nset_bank_2(pi, 0x303)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_mode-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_mode","text":"set_mode(pi::Pi, pin::Int, mode)\n\nSets the GPIO mode of the given pin (integer between 0 and 53) of the Pi instance pi. The mode con be PiGPIO.INPUT, PiGPIO.OUTPUT, PiGPIO.ALT0, PiGPIO.ALT1, PiGPIO.ALT2, PiGPIO.ALT3, PiGPIO.ALT4 or PiGPIO.ALT5.\n\nset_mode(pi,  4, PiGPIO.INPUT)  # GPIO  4 as input\nset_mode(pi, 17, PiGPIO.OUTPUT) # GPIO 17 as output\nset_mode(pi, 24, PiGPIO.ALT2)   # GPIO 24 as ALT2\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_pull_up_down-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_pull_up_down","text":"set_pull_up_down(self::Pi, gpio, pud)\n\nSets or clears the internal GPIO pull-up/down resistor for the pin gpio (integer between 0 and 53). Possible values for pud are PiGPIO.PUD_UP, PiGPIO.PUD_DOWN or PiGPIO.PUD_OFF.\n\nset_pull_up_down(pi, 17, PiGPIO.PUD_OFF)\nset_pull_up_down(pi, 23, PiGPIO.PUD_UP)\nset_pull_up_down(pi, 24, PiGPIO.PUD_DOWN)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_servo_pulsewidth-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_servo_pulsewidth","text":"Starts (500-2500) or stops (0) servo pulses on the GPIO.\n\nuser_gpio: 0-31.\npulsewidth: 0 (off), 500 (most anti-clockwise) - 2500 (most clockwise).\n\nThe selected pulsewidth will continue to be transmitted until changed by a subsequent call to setservopulsewidth.\n\nThe pulsewidths supported by servos varies and should probably be determined by experiment. A value of 1500 should always be safe and represents the mid-point of rotation.\n\nYou can DAMAGE a servo if you command it to move beyond its limits.\n\nset_servo_pulsewidth(pi, 17, 0)    # off\nset_servo_pulsewidth(pi, 17, 1000) # safe anti-clockwise\nset_servo_pulsewidth(pi, 17, 1500) # centre\nset_servo_pulsewidth(pi, 17, 2000) # safe clockwise\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.set_watchdog-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.set_watchdog","text":"Sets a watchdog timeout for a GPIO.\n\nuser_gpio: 0-31.\nwdog_timeout: 0-60000.\n\nThe watchdog is nominally in milliseconds.\n\nOnly one watchdog may be registered per GPIO.\n\nThe watchdog may be cancelled by setting timeout to 0.\n\nIf no level change has been detected for the GPIO for timeout milliseconds any notification for the GPIO has a report written to the fifo with the flags set to indicate a watchdog timeout.\n\nThe callback class interprets the flags and will call registered callbacks for the GPIO with level TIMEOUT.\n\nset_watchdog(pi, 23, 1000) # 1000 ms watchdog on GPIO 23\nset_watchdog(pi, 23, 0)    # cancel watchdog on GPIO 23\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.spi_close-Tuple{Any, Any}","page":"API Docs","title":"PiGPIO.spi_close","text":"Closes the SPI device associated with handle.\n\nhandle: >=0 (as returned by a prior call to spi_open).\n\nspi_close(pi, h)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.spi_open","page":"API Docs","title":"PiGPIO.spi_open","text":"Returns a handle for the SPI device on channel.  Data will be transferred at baud bits per second.  The flags may be used to modify the default behaviour of 4-wire operation, mode 0, active low chip select.\n\nAn auxiliary SPI device is available on all models but the A and B and may be selected by setting the A bit in the flags. The auxiliary device has 3 chip selects and a selectable word size in bits.\n\nspi_channel: 0-1 (0-2 for the auxiliary SPI device).\nbaud: 32K-125M (values above 30M are unlikely to work).\nspi_flags: see below.\n\nNormally you would only use the spi_* functions if you are or will be connecting to the Pi over a network.  If you will always run on the local Pi use the standard SPI module instead.\n\nspi_flags consists of the least significant 22 bits.\n\n. . 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m . .\n\nmm defines the SPI mode.\n\nwarning: Warning\nmodes 1 and 3 do not appear to work on the auxiliary device.\n\n. . Mode POL PHA 0    0   0 1    0   1 2    1   0 3    1   1 . .\n\npx is 0 if CEx is active low (default) and 1 for active high.\n\nux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.\n\nA is 0 for the standard SPI device, 1 for the auxiliary SPI.\n\nW is 0 if the device is not 3-wire, 1 if the device is 3-wire. Standard SPI device only.\n\nnnnn defines the number of bytes (0-15) to write before switching the MOSI line to MISO to read data.  This field is ignored if W is not set.  Standard SPI device only.\n\nT is 1 if the least significant bit is transmitted on MOSI first, the default (0) shifts the most significant bit out first.  Auxiliary SPI device only.\n\nR is 1 if the least significant bit is received on MISO first, the default (0) receives the most significant bit first.  Auxiliary SPI device only.\n\nbbbbbb defines the word size in bits (0-32).  The default (0) sets 8 bits per word.  Auxiliary SPI device only.\n\nThe spi_read, spi_write, and spi_xfer functions transfer data packed into 1, 2, or 4 bytes according to the word size in bits.\n\nFor bits 1-8 there will be one byte per character. For bits 9-16 there will be two bytes per character. For bits 17-32 there will be four bytes per character.\n\nE.g. 32 12-bit words will be transferred in 64 bytes.\n\nThe other bits in flags should be set to zero.\n\n# open SPI device on channel 1 in mode 3 at 50000 bits per second\n\nh = spi_open(pi, 1, 50000, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.spi_read-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.spi_read","text":"Reads count bytes from the SPI device associated with handle.\n\nhandle: >=0 (as returned by a prior call to spi_open).\ncount: >0, the number of bytes to read.\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(b, d) = spi_read(pi, h, 60) # read 60 bytes from device h\nif b == 60\n# process read data\nelse\n# error path\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.spi_write-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.spi_write","text":"Writes the data bytes to the SPI device associated with handle.\n\nhandle: >=0 (as returned by a prior call to spi_open).\ndata: the bytes to write.\n\nspi_write(pi, 0, b'\\x02\\xc0\\x80') # write 3 bytes to device 0\n\nspi_write(pi, 0, b'defgh')        # write 5 bytes to device 0\n\nspi_write(pi, 0, \"def\")           # write 3 bytes to device 0\n\nspi_write(pi, 1, [2, 192, 128])   # write 3 bytes to device 1\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.spi_xfer-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.spi_xfer","text":"Writes the data bytes to the SPI device associated with handle, returning the data bytes read from the device.\n\nhandle: >=0 (as returned by a prior call to spi_open).\ndata: the bytes to write.\n\nThe returned value is a tuple of the number of bytes read and a bytearray containing the bytes.  If there was an error the number of bytes read will be less than zero (and will contain the error code).\n\n(count, rx_data) = spi_xfer(pi, h, b'\\x01\\x80\\x00')\n\n(count, rx_data) = spi_xfer(pi, h, [1, 128, 0])\n\n(count, rx_data) = spi_xfer(pi, h, b\"hello\")\n\n(count, rx_data) = spi_xfer(pi, h, \"hello\")\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.stop-Tuple{PiGPIO.CallbackThread}","page":"API Docs","title":"PiGPIO.stop","text":"PiGPIO.stop(self::CallbackThread)\n\nStops notifications.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.stop-Tuple{Pi}","page":"API Docs","title":"PiGPIO.stop","text":"PiGPIO.stop(self::Pi)\n\nRelease pigpio resources.\n\nPiGPIO.stop(pi)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.tally-Tuple{PiGPIO.Callback}","page":"API Docs","title":"PiGPIO.tally","text":"Provides a count of how many times the default tally callback has triggered.\n\nThe count will be zero if the user has supplied their own callback function.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.tickDiff-Tuple{Any, Any}","page":"API Docs","title":"PiGPIO.tickDiff","text":"PiGPIO.tickDiff(t1,t2)\n\nReturns the microsecond difference between two ticks t1 (the earlier tick) and t2 the later tick. If t2 - t1 < 0, it is assumed that the time counter wrapped around the Int32 limit.\n\nprint(PiGPIO.tickDiff(4294967272, 12))\n# output 36\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wait_for_edge","page":"API Docs","title":"PiGPIO.wait_for_edge","text":"Wait for an edge event on a GPIO.\n\nuser_gpio: 0-31.\nedge: PiGPIO.EITHER_EDGE, PiGPIO.RISING_EDGE (default), or        PiGPIO.FALLING_EDGE.\nwait_timeout: >=0.0 (default 60.0).\n\nThe function returns when the edge is detected or after the number of seconds specified by timeout has expired.\n\nDo not use this function for precise timing purposes, the edge is only checked 20 times a second. Whenever you need to know the accurate time of GPIO events use a callback function.\n\nThe function returns true if the edge is detected, otherwise false.\n\nif wait_for_edge(pi, 23)\nprint(\"Rising edge detected\")\nelse\nprint(\"wait for edge timed out\")\n\nif wait_for_edge(pi, 23, PiGPIO.FALLING_EDGE, 5.0)\nprint(\"Falling edge detected\")\nelse\nprint(\"wait for falling edge timed out\")\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.wave_add_generic-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.wave_add_generic","text":"Adds a list of pulses to the current waveform.\n\npulses: list of pulses to add to the waveform.\n\nReturns the new total number of pulses in the current waveform.\n\nThe pulses are interleaved in time order within the existing waveform (if any).\n\nMerging allows the waveform to be built in parts, that is the settings for GPIO#1 can be added, and then GPIO#2 etc.\n\nIf the added waveform is intended to start after or within the existing waveform then the first pulse should consist solely of a delay.\n\nG1=4\nG2=24\n\nset_mode(pi, G1, pigpio.OUTPUT)\nset_mode(pi, G2, pigpio.OUTPUT)\n\nflash_500=[] # flash every 500 ms\nflash_100=[] # flash every 100 ms\n\n#                              ON     OFF  DELAY\n\nflash_500.append(pigpio.pulse(1<<G1, 1<<G2, 500000))\nflash_500.append(pigpio.pulse(1<<G2, 1<<G1, 500000))\n\nflash_100.append(pigpio.pulse(1<<G1, 1<<G2, 100000))\nflash_100.append(pigpio.pulse(1<<G2, 1<<G1, 100000))\n\nwave_clear(pi, ) # clear any existing waveforms\n\nwave_add_generic(pi, flash_500) # 500 ms flashes\nf500 = wave_create(pi, ) # create and save id\n\nwave_add_generic(pi, flash_100) # 100 ms flashes\nf100 = wave_create(pi, ) # create and save id\n\nwave_send_repeat(pi, f500)\n\ntime.sleep(4)\n\nwave_send_repeat(pi, f100)\n\ntime.sleep(4)\n\nwave_send_repeat(pi, f500)\n\ntime.sleep(4)\n\nwave_tx_stop(pi, ) # stop waveform\n\nwave_clear(pi, ) # clear all waveforms\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_add_new-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_add_new","text":"Starts a new empty waveform.\n\nYou would not normally need to call this function as it is automatically called after a waveform is created with the wave_create function.\n\nwave_add_new(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_add_serial","page":"API Docs","title":"PiGPIO.wave_add_serial","text":"Adds a waveform representing serial data to the existing waveform (if any).  The serial data starts offset microseconds from the start of the waveform.\n\nuser_gpio: GPIO to transmit data.  You must set the GPIO mode to output.\nbaud: 50-1000000 bits per second.\ndata: the bytes to write.\noffset: number of microseconds from the start of the waveform, default 0.\nbb_bits: number of data bits, default 8.\nbb_stop: number of stop half bits, default 2.\n\nReturns the new total number of pulses in the current waveform.\n\nThe serial data is formatted as one start bit, bb_bits data bits, and bb_stop/2 stop bits.\n\nIt is legal to add serial data streams with different baud rates to the same waveform.\n\nThe bytes required for each character depend upon bb_bits.\n\nFor bb_bits 1-8 there will be one byte per character. For bb_bits 9-16 there will be two bytes per character. For bb_bits 17-32 there will be four bytes per character.\n\nwave_add_serial(pi, 4, 300, 'Hello world')\n\nwave_add_serial(pi, 4, 300, b\"Hello world\")\n\nwave_add_serial(pi, 4, 300, b'\\x23\\x01\\x00\\x45')\n\nwave_add_serial(pi, 17, 38400, [23, 128, 234], 5000)\n\n\n\n\n\n","category":"function"},{"location":"api/#PiGPIO.wave_chain-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.wave_chain","text":"This function transmits a chain of waveforms.\n\nnote: Note\nAny hardware PWM started by hardware_PWM will be cancelled.\n\nThe waves to be transmitted are specified by the contents of data which contains an ordered list of wave_ids and optional command codes and related data.\n\nReturns 0 if OK, otherwise PICHAINNESTING, PICHAINLOOPCNT, PIBADCHAINLOOP, PIBADCHAINCMD, PICHAINCOUNTER, PIBADCHAINDELAY, PICHAINTOOBIG, or PIBADWAVEID.\n\nEach wave is transmitted in the order specified.  A wave may occur multiple times per chain.\n\nA blocks of waves may be transmitted multiple times by using the loop commands. The block is bracketed by loop start and end commands.  Loops may be nested.\n\nDelays between waves may be added with the delay command.\n\nThe following command codes are supported\n\nName         @ Cmd & Data @ Meaning\nLoop Start   @ 255 0      @ Identify start of a wave block\nLoop Repeat  @ 255 1 x y  @ loop x + y*256 times\nDelay        @ 255 2 x y  @ delay x + y*256 microseconds\nLoop Forever @ 255 3      @ loop forever\n\nIf present Loop Forever must be the last entry in the chain.\n\nThe code is currently dimensioned to support a chain with roughly 600 entries and 20 loop counters.\n\n#!/usr/bin/env python\n\nimport time\nimport pigpio\n\nWAVES=5\nGPIO=4\n\nwid=[0]*WAVES\n\npi = pigpio.pi() # Connect to local Pi.\n\nset_mode(pi, GPIO, pigpio.OUTPUT);\n\nfor i in range(WAVES)\npi.wave_add_generic([\npigpio.pulse(1<<GPIO, 0, 20),\npigpio.pulse(0, 1<<GPIO, (i+1)*200)]);\n\nwid[i] = wave_create(pi, );\n\npi.wave_chain([\nwid[4], wid[3], wid[2],       # transmit waves 4+3+2\n255, 0,                       # loop start\nwid[0], wid[0], wid[0],    # transmit waves 0+0+0\n255, 0,                    # loop start\n   wid[0], wid[1],         # transmit waves 0+1\n   255, 2, 0x88, 0x13,     # delay 5000us\n255, 1, 30, 0,             # loop end (repeat 30 times)\n255, 0,                    # loop start\n   wid[2], wid[3], wid[0], # transmit waves 2+3+0\n   wid[3], wid[1], wid[2], # transmit waves 3+1+2\n255, 1, 10, 0,             # loop end (repeat 10 times)\n255, 1, 5, 0,                 # loop end (repeat 5 times)\nwid[4], wid[4], wid[4],       # transmit waves 4+4+4\n255, 2, 0x20, 0x4E,           # delay 20000us\nwid[0], wid[0], wid[0],       # transmit waves 0+0+0\n])\n\nwhile wave_tx_busy(pi, )\ntime.sleep(0.1);\n\nfor i in range(WAVES)\nwave_delete(pi, wid[i])\n\nstop(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_clear-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_clear","text":"Clears all waveforms and any data added by calls to the wave_add_* functions.\n\nwave_clear(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_create-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_create","text":"Creates a waveform from the data provided by the prior calls to the wave_add_* functions.\n\nReturns a wave id (>=0) if OK,  otherwise PIEMPTYWAVEFORM, PITOOMANYCBS, PITOOMANYOOL, or PINOWAVEFORM_ID.\n\nThe data provided by the wave_add_* functions is consumed by this function.\n\nAs many waveforms may be created as there is space available. The wave id is passed to wave_send_* to specify the waveform to transmit.\n\nNormal usage would be\n\nStep 1. wave_clear to clear all waveforms and added data.\n\nStep 2. wave_add_* calls to supply the waveform data.\n\nStep 3. wave_create to create the waveform and get a unique id\n\nRepeat steps 2 and 3 as needed.\n\nStep 4. wave_send_* with the id of the waveform to transmit.\n\nA waveform comprises one or more pulses.\n\nA pulse specifies\n\nthe GPIO to be switched on at the start of the pulse.\nthe GPIO to be switched off at the start of the pulse.\nthe delay in microseconds before the next pulse.\n\nAny or all the fields can be zero.  It doesn't make any sense to set all the fields to zero (the pulse will be ignored).\n\nWhen a waveform is started each pulse is executed in order with the specified delay between the pulse and the next.\n\nwid = wave_create(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_delete-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.wave_delete","text":"This function deletes the waveform with id wave_id.\n\nwave_id: >=0 (as returned by a prior call to wave_create).\n\nWave ids are allocated in order, 0, 1, 2, etc.\n\nwave_delete(pi, 6) # delete waveform with id 6\n\nwave_delete(pi, 0) # delete waveform with id 0\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_cbs-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_cbs","text":"Returns the length in DMA control blocks of the current waveform.\n\ncbs = wave_get_cbs(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_max_cbs-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_max_cbs","text":"Returns the maximum possible size of a waveform in DMA control blocks.\n\ncbs = wave_get_max_cbs(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_max_micros-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_max_micros","text":"Returns the maximum possible size of a waveform in microseconds.\n\nmicros = wave_get_max_micros(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_max_pulses-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_max_pulses","text":"Returns the maximum possible size of a waveform in pulses.\n\npulses = wave_get_max_pulses(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_micros-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_micros","text":"Returns the length in microseconds of the current waveform.\n\nmicros = wave_get_micros(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_get_pulses-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_get_pulses","text":"Returns the length in pulses of the current waveform.\n\npulses = wave_get_pulses(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_send_once-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.wave_send_once","text":"Transmits the waveform with id wave_id.  The waveform is sent once.\n\nnote: Note\nAny hardware PWM started by hardware_PWM will be cancelled.\n\nwave_id: >=0 (as returned by a prior call to wave_create).\n\nReturns the number of DMA control blocks used in the waveform.\n\ncbs = wave_send_once(pi, wid)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_send_repeat-Tuple{Pi, Any}","page":"API Docs","title":"PiGPIO.wave_send_repeat","text":"PiGPIO.wave_send_repeat(self::Pi, wave_id)\n\nTransmits the waveform with id wave_id.  The waveform repeats until wave_tx_stop is called or another call to wave_send_* is made.\n\nnote: Note\nAny hardware PWM started by hardware_PWM will be cancelled.\n\nwave_id: >=0 (as returned by a prior call to wave_create).\n\nReturns the number of DMA control blocks used in the waveform.\n\ncbs = wave_send_repeat(pi, wid)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_send_using_mode-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.wave_send_using_mode","text":"Transmits the waveform with id wave_id using mode mode.\n\nwave_id: >0= (as returned by a prior call to wave_create).\nmode: PiGPIO.WAVE_MODE_ONE_SHOT, PiGPIO.WAVE_MODE_REPEAT,  PiGPIO.WAVE_MODE_ONE_SHOT_SYNC, or PiGPIO.WAVE_MODE_REPEAT_SYNC.\n\nPiGPIO.WAVE_MODE_ONE_SHOT: same as wave_send_once.\n\nPiGPIO.WAVE_MODE_REPEAT same as wave_send_repeat.\n\nPiGPIO.WAVE_MODE_ONE_SHOT_SYNC same as wave_send_once but tries to sync with the previous waveform.\n\nPiGPIO.WAVE_MODE_REPEAT_SYNC same as wave_send_repeat but tries to sync with the previous waveform.\n\nwarning: Warning\nBad things may happen if you delete the previous waveform before it has been synced to the new waveform.\n\nnote: Note\nAny hardware PWM started by hardware_PWM will be cancelled.\n\nwave_id: >=0 (as returned by a prior call to wave_create).\n\nReturns the number of DMA control blocks used in the waveform.\n\ncbs = wave_send_using_mode(pi, wid, PiGPIO.WAVE_MODE_REPEAT_SYNC)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_tx_at-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_tx_at","text":"Returns the id of the waveform currently being transmitted.\n\nReturns the waveform id or one of the following special values\n\nPiGPIO.WAVE_NOT_FOUND (9998) - transmitted wave not found. PiGPIO.NO_TX_WAVE (9999) - no wave being transmitted.\n\nwid = wave_tx_at(pi, )\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_tx_busy-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_tx_busy","text":"Returns 1 if a waveform is currently being transmitted, otherwise 0.\n\nwave_send_once(pi, 0) # send first waveform\n\nwhile wave_tx_busy(pi, ): # wait for waveform to be sent\ntime.sleep(0.1)\n\nwave_send_once(pi, 1) # send next waveform\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_tx_repeat-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_tx_repeat","text":"This function is deprecated and has beeen removed.\n\nUse wave_create/wave_send_* instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_tx_start-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_tx_start","text":"This function is deprecated and has been removed.\n\nUse wave_create/wave_send_* instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.wave_tx_stop-Tuple{Pi}","page":"API Docs","title":"PiGPIO.wave_tx_stop","text":"Stops the transmission of the current waveform.\n\nThis function is intended to stop a waveform started with wave_send_repeat.\n\nwave_send_repeat(pi, 3)\n\nsleep(5)\n\nwave_tx_stop(pi)\n\n\n\n\n\n","category":"method"},{"location":"api/#PiGPIO.write-Tuple{Pi, Any, Any}","page":"API Docs","title":"PiGPIO.write","text":"write(self::Pi, gpio, level)\n\nSets the GPIO level for the pin gpio (an integer between 0 and 53) where level is 0 or 1.\n\nIf PWM or servo pulses are active on the GPIO they are switched off.\n\nset_mode(pi, 17, PiGPIO.OUTPUT)\n\nwrite(pi, 17,0)\nprint(read(pi, 17))\n# output 0\n\nwrite(pi, 17,1)\nprint(read(pi, 17))\n# output 1\n\n\n\n\n\n","category":"method"},{"location":"examples/03_rgb/","page":"Red-Green-Blue","title":"Red-Green-Blue","text":"EditURL = \"../../../examples/03_rgb.jl\"","category":"page"},{"location":"examples/03_rgb/","page":"Red-Green-Blue","title":"Red-Green-Blue","text":"using PiGPIO\n\nred_pin = 23\ngreen_pin = 24\nblue_pin = 25\np=Pi()\n\n\n\nusing Colors\n\ndc = distinguishable_colors(10)\n\nfor r in dc\n    set_PWM_dutycycle(p, red_pin, round(Int, r.r*255))\n    set_PWM_dutycycle(p, green_pin, round(Int,r.g*255))\n    set_PWM_dutycycle(p, blue_pin, round(Int,r.b*255))\n    sleep(0.5)\nend\n\nset_PWM_dutycycle(p, red_pin, 0)\nset_PWM_dutycycle(p, green_pin, 0)\nset_PWM_dutycycle(p, blue_pin, 0)\n\nusing SIUnits\nusing SIUnits.ShortUnits\n\nfunction normalize0(c::XYZ)\n    d=convert(xyY, c)\n    xyY(d.x, d.y, 1.0)\nend\n\nconst hc_k  = 0.0143877696*K*m\nconst twohc²= 1.19104287e-16*Watt*m^2\nplanck{S1<:Real, S2<:Real}(λ::quantity(S1,Meter); T::quantity(S2,Kelvin)=5778.0K) =\n    λ≤0m ? zero(λ)*Watt*m^-4 : twohc²*λ^-5.0/(exp(hc_k/(λ*T))-1)\n\nBase.convert{S<:Real}(::Type{xyY}, T::quantity(S, K)) =\n  mapreduce(λ->planck(λ*nm,T=T)*m^3/Watt*colormatch(λ), +, 380:780) |>\n  normalize0\n\nblackbodies = xyY[convert(xyY, T) for T in 100K:200K:10000K]\n\nfor b in blackbodies\n     r=convert(RGB, b)\n     set_PWM_dutycycle(p, red_pin, round(Int, r.r*255))\n     set_PWM_dutycycle(p, green_pin, round(Int,r.g*255))\n     set_PWM_dutycycle(p, blue_pin, round(Int,r.b*255))\n     sleep(0.5)\nend","category":"page"},{"location":"examples/03_rgb/","page":"Red-Green-Blue","title":"Red-Green-Blue","text":"","category":"page"},{"location":"examples/03_rgb/","page":"Red-Green-Blue","title":"Red-Green-Blue","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/01_blink/","page":"Blink Once","title":"Blink Once","text":"EditURL = \"../../../examples/01_blink.jl\"","category":"page"},{"location":"examples/01_blink/","page":"Blink Once","title":"Blink Once","text":"using PiGPIO\n\nred_pin = 18 #change this accordingly with your GPIO pin number\np=Pi()\nset_mode(p, red_pin, PiGPIO.OUTPUT)\ntry\n    for i in 1:10\n        PiGPIO.write(p, red_pin, PiGPIO.HIGH)\n        sleep(0.5)\n        PiGPIO.write(p, red_pin, PiGPIO.LOW)\n        sleep(0.5)\n    end\nfinally\n    println(\"Cleaning up!\")\n    set_mode(p, red_pin, PiGPIO.INPUT)\nend","category":"page"},{"location":"examples/01_blink/","page":"Blink Once","title":"Blink Once","text":"","category":"page"},{"location":"examples/01_blink/","page":"Blink Once","title":"Blink Once","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/02_blink_twice/","page":"Blink Twice","title":"Blink Twice","text":"EditURL = \"../../../examples/02_blink_twice.jl\"","category":"page"},{"location":"examples/02_blink_twice/","page":"Blink Twice","title":"Blink Twice","text":"using PiGPIO\n\nred_pin1 = 18 #change these numbers accordingly with your GPIO pins\nred_pin2 = 23\n\np=Pi()\n\nset_mode(p, red_pin1, PiGPIO.OUTPUT)\nset_mode(p, red_pin2, PiGPIO.OUTPUT)\n\ntry\n    for i in 1:10\n        PiGPIO.write(p, red_pin1, PiGPIO.HIGH)\n        PiGPIO.write(p, red_pin2, PiGPIO.LOW)\n        sleep(0.5)\n        PiGPIO.write(p, red_pin1, PiGPIO.LOW)\n        PiGPIO.write(p, red_pin2, PiGPIO.HIGH)\n        sleep(0.5)\n    end\nfinally\n    println(\"Cleaning up!\")\n    set_mode(p, red_pin1, PiGPIO.INPUT)\n    set_mode(p, red_pin2, PiGPIO.INPUT)\nend","category":"page"},{"location":"examples/02_blink_twice/","page":"Blink Twice","title":"Blink Twice","text":"","category":"page"},{"location":"examples/02_blink_twice/","page":"Blink Twice","title":"Blink Twice","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PiGPIO.jl","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"Documentation for PiGPIO.jl","category":"page"},{"location":"#Control-GPIO-pins-on-the-Raspberry-Pi-from-Julia","page":"PiGPIO.jl","title":"Control GPIO pins on the Raspberry Pi from Julia","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"(Image: PiGPIO)","category":"page"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"PiGPIO.jl is a Julia package for the Raspberry which communicates with the pigpio daemon to allow control of the general purpose input outputs (GPIO).","category":"page"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"This package is effectively a translation of the python package of the same. Which can be found here","category":"page"},{"location":"#Features","page":"PiGPIO.jl","title":"Features","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"OS independent. Only Julia 1.0+ required.\nControls one or more Pi's.\nHardware timed pulse width modulation.\nHardware timed servo pulse.\nCallbacks when any of GPIO change state.\nCreate and transmit precise waveforms.\nRead/Write GPIO and set their modes.\nWrappers for I2C, SPI, and serial links.","category":"page"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"Once a pigpio daemon is launched on the pi this package can connect to it and communicate with it to manipulate the GPIO pins of the pi. The actual work is done by the daemon. One benefit of working this way is that you can remotely access the pi over a network and multiple instances can be connected to the daemon simultaneously.","category":"page"},{"location":"#Launching-the-Daemon","page":"PiGPIO.jl","title":"Launching the Daemon","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"Launching the daemon requires sudo privileges. Launch by typing sudo pigpiod in the terminal.","category":"page"},{"location":"#Installation-and-Usage","page":"PiGPIO.jl","title":"Installation and Usage","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"using Pkg\nPkg.add(\"PiGPIO\")\n\nusing PiGPIO\n\npi=Pi() #connect to pigpiod daemon on localhost","category":"page"},{"location":"#Example-Usage","page":"PiGPIO.jl","title":"Example Usage","text":"","category":"section"},{"location":"","page":"PiGPIO.jl","title":"PiGPIO.jl","text":"set_mode(p::Pi, pin::Int, mode)\nget_mode(p::Pi, pin::Int)\n# mode can be INPUT or OUTPUT\n\nPiGPIO.read(p, pin)\nPiGPIO.write(p, pin, state)\n#state can be HIGH, LOW, ON, OFF\n\nPiGPIO.set_PWM_dutycycle(p, pin, dutycyle)\n#dutycyle defaults to a range 0-255","category":"page"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Via this tutorial, we shall be going over the entire process of installation and use of the Julia Programming language on a Raspberry Pi. We will be using the PiGPIO.jl library for controlling GPIO elements (namely LEDs). We shall be building a simple circuit of two alternately blinking LEDs.","category":"page"},{"location":"tutorial/#What-you'll-need","page":"Tutorial","title":"What you'll need","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You will require a Raspberry Pi (I am using a Raspberry Pi 3 model B+), along with the standard peripherals(keyboard, mouse, display, power supply), 1 breadboard, 2 resistors, 2 LEDs and jumper wires. I am assuming that you have the Raspbian OS set up and running on the Raspberry Pi. If not, take a look at this tutorial.","category":"page"},{"location":"tutorial/#Setting-up-Julia","page":"Tutorial","title":"Setting up Julia","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In your Raspbian commmand line, simply run:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sudo apt install julia","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we need to launch a pigpio daemon, which PiGPIO.jl can connect to and control the GPIO pins. To do this, run the following command.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sudo pigpiod","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, run this to enter the Julia REPL","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"now run the following commands to install the PiGPIO library:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"PiGPIO\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You should now be ready to start with the circuit","category":"page"},{"location":"tutorial/#Building-the-Circuit","page":"Tutorial","title":"Building the Circuit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"connect the cathode of both the LEDs to the ground rail of the breadboard. Connect the anode, via an appropriate resistor (I used 82 ohm) to GPIO pins 2 and 3 of the Raspberry Pi.","category":"page"},{"location":"tutorial/#circuit-diagram-for-reference:","page":"Tutorial","title":"circuit diagram for reference:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You are now ready to launch Julia and start coding. PiGPIO.jl should be installed by now.","category":"page"},{"location":"tutorial/#The-Code","page":"Tutorial","title":"The Code","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can run this code through an external text editor or in the Julia REPL itself. First we need to import the package with the using keyword. Next, we need to initialize the Raspberry Pi by creating an object variable and initialising it to Pi()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PiGPIO\npi = Pi()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we need to intitialize the GPIO pins and their state (INPUT/OUTPUT –> in this case OUTPUT).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pin1 = 2 # GPIO pin 2\npin2 = 3 # GPIO pin 3\n\nset_mode(pi, pin1, PiGPIO.OUTPUT) \nset_mode(pi, pin2, PiGPIO.OUTPUT)\n# ^ initialization","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we shall use a for loop to implement the blinking LEDs","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"num_loops = 20 # The number of times you want the lights to blink. \nfor i = 1:num_loops\n    PiGPIO.write(pi, pin1, HIGH) # setting GPIO pin state\n    PiGPIO.write(pi, pin2, LOW)\n    sleep(1) # delay in seconds\n    PiGPIO.write(pi, pin1, LOW)\n    PiGPIO.write(pi, pin2, HIGH)\n    sleep(1)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You should be getting blinking LEDs when you run this code. ","category":"page"},{"location":"tutorial/#pictures-of-the-final-working-model:","page":"Tutorial","title":"pictures of the final working model:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This project was made by Nand Vinchhi for the purpose of GCI 2019.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Circuit diagrams drawn with circuit-diagram.org","category":"page"}]
}
